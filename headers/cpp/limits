// The template and inlines for the numeric_limits classes. -*- C++ -*-

// Copyright (C) 1999-2013 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/limits
 *  This is a Standard C++ Library header.
 */

// Note: this is not a conforming implementation.
// Written by Gabriel Dos Reis <gdr@codesourcery.com>

//
// ISO 14882:1998
// 18.2.1
//

#ifndef _GLIBCXX_NUMERIC_LIMITS
#define _GLIBCXX_NUMERIC_LIMITS 1

#pragma GCC system_header

#include <float.h>
#include <limits.h>
#include <math.h>


//
// The numeric_limits<> traits document implementation-defined aspects
// of fundamental arithmetic data types (integers and floating points).
// From Standard C++ point of view, there are 14 such types:
//   * integers
//         bool							(1)
//         char, signed char, unsigned char, wchar_t            (4)
//         short, unsigned short				(2)
//         int, unsigned					(2)
//         long, unsigned long					(2)
//
//   * floating points
//         float						(1)
//         double						(1)
//         long double						(1)
//
// GNU C++ understands (where supported by the host C-library)
//   * integer
//         long long, unsigned long long			(2)
//
// which brings us to 16 fundamental arithmetic data types in GNU C++.
//
//
// Since a numeric_limits<> is a bit tricky to get right, we rely on
// an interface composed of macros which should be defined in config/os
// or config/cpu when they differ from the generic (read arbitrary)
// definitions given here.
//

// These values can be overridden in the target configuration file.
// The default values are appropriate for many 32-bit targets.

// GCC only intrinsically supports modulo integral types.  The only remaining
// integral exceptional values is division by zero.  Only targets that do not
// signal division by zero in some "hard to ignore" way should use false.
#ifndef __glibcxx_integral_traps
# define __glibcxx_integral_traps true
#endif

// float
//

// Default values.  Should be overridden in configuration files if necessary.

#ifndef __glibcxx_float_has_denorm_loss
#  define __glibcxx_float_has_denorm_loss false
#endif
#ifndef __glibcxx_float_traps
#  define __glibcxx_float_traps false
#endif
#ifndef __glibcxx_float_tinyness_before
#  define __glibcxx_float_tinyness_before false
#endif

// double

// Default values.  Should be overridden in configuration files if necessary.

#ifndef __glibcxx_double_has_denorm_loss
#  define __glibcxx_double_has_denorm_loss false
#endif
#ifndef __glibcxx_double_traps
#  define __glibcxx_double_traps false
#endif
#ifndef __glibcxx_double_tinyness_before
#  define __glibcxx_double_tinyness_before false
#endif

// long double

// Default values.  Should be overridden in configuration files if necessary.

#ifndef __glibcxx_long_double_has_denorm_loss
#  define __glibcxx_long_double_has_denorm_loss false
#endif
#ifndef __glibcxx_long_double_traps
#  define __glibcxx_long_double_traps false
#endif
#ifndef __glibcxx_long_double_tinyness_before
#  define __glibcxx_long_double_tinyness_before false
#endif

// You should not need to define any macros below this point.

#define __glibcxx_signed(T)	((T)(-1) < 0)

#define __glibcxx_min(T) \
  (__glibcxx_signed (T) ? -__glibcxx_max (T) - 1 : (T)0)

#define __glibcxx_max(T) \
  (__glibcxx_signed (T) ? \
   (((((T)1 << (__glibcxx_digits (T) - 1)) - 1) << 1) + 1) : ~(T)0)

#define __glibcxx_digits(T) \
  (sizeof(T) * CHAR_BIT - __glibcxx_signed (T))

// The fraction 643/2136 approximates log10(2) to 7 significant digits.
#define __glibcxx_digits10(T) \
  (__glibcxx_digits (T) * 643L / 2136)

#define __glibcxx_max_digits10(T) \
  (2 + (T) * 643L / 2136)

namespace std
{

  /**
   *  @brief Describes the rounding style for floating-point types.
   *
   *  This is used in the std::numeric_limits class.
  */
  enum float_round_style
  {
    round_indeterminate       = -1,    /// Intermediate.
    round_toward_zero         = 0,     /// To zero.
    round_to_nearest          = 1,     /// To the nearest representable value.
    round_toward_infinity     = 2,     /// To infinity.
    round_toward_neg_infinity = 3      /// To negative infinity.
  };

  /**
   *  @brief Describes the denormalization for floating-point types.
   *
   *  These values represent the presence or absence of a variable number
   *  of exponent bits.  This type is used in the std::numeric_limits class.
  */
  enum float_denorm_style
  {
    /// Indeterminate at compile time whether denormalized values are allowed.
    denorm_indeterminate = -1,
    /// The type does not allow denormalized values.
    denorm_absent        = 0,
    /// The type allows denormalized values.
    denorm_present       = 1
  };

  /**
   *  @brief Part of std::numeric_limits.
   *
   *  The @c static @c const members are usable as integral constant
   *  expressions.
   *
   *  @note This is a separate class for purposes of efficiency; you
   *        should only access these members as part of an instantiation
   *        of the std::numeric_limits class.
  */
  struct __numeric_limits_base
  {
    /** This will be true for all fundamental types (which have
	specializations), and false for everything else.  */
    static const bool is_specialized = false;

    /** The number of @c radix digits that be represented without change:  for
	integer types, the number of non-sign bits in the mantissa; for
	floating types, the number of @c radix digits in the mantissa.  */
    static const int digits = 0;

    /** The number of base 10 digits that can be represented without change. */
    static const int digits10 = 0;

#if __cplusplus >= 201103L
    /** The number of base 10 digits required to ensure that values which
	differ are always differentiated.  */
    static constexpr int max_digits10 = 0;
#endif

    /** True if the type is signed.  */
    static const bool is_signed = false;

    /** True if the type is integer.  */
    static const bool is_integer = false;

    /** True if the type uses an exact representation. All integer types are
	exact, but not all exact types are integer.  For example, rational and
	fixed-exponent representations are exact but not integer. */
    static const bool is_exact = false;

    /** For integer types, specifies the base of the representation.  For
	floating types, specifies the base of the exponent representation.  */
    static const int radix = 0;

    /** The minimum negative integer such that @c radix raised to the power of
	(one less than that integer) is a normalized floating point number.  */
    static const int min_exponent = 0;

    /** The minimum negative integer such that 10 raised to that power is in
	the range of normalized floating point numbers.  */
    static const int min_exponent10 = 0;

    /** The maximum positive integer such that @c radix raised to the power of
	(one less than that integer) is a representable finite floating point
	number.  */
    static const int max_exponent = 0;

    /** The maximum positive integer such that 10 raised to that power is in
	the range of representable finite floating point numbers.  */
    static const int max_exponent10 = 0;

    /** True if the type has a representation for positive infinity.  */
    static const bool has_infinity = false;

    /** True if the type has a representation for a quiet (non-signaling)
	Not a Number.  */
    static const bool has_quiet_NaN = false;

    /** True if the type has a representation for a signaling
	Not a Number.  */
    static const bool has_signaling_NaN = false;

    /** See std::float_denorm_style for more information.  */
    static const float_denorm_style has_denorm = denorm_absent;

    /** True if loss of accuracy is detected as a denormalization loss,
	rather than as an inexact result. */
    static const bool has_denorm_loss = false;

    /** True if-and-only-if the type adheres to the IEC 559 standard, also
	known as IEEE 754.  (Only makes sense for floating point types.)  */
    static const bool is_iec559 = false;

    /** True if the set of values representable by the type is
	finite.  All built-in types are bounded, this member would be
	false for arbitrary precision types. */
    static const bool is_bounded = false;

    /** True if the type is @e modulo. A type is modulo if, for any
	operation involving +, -, or * on values of that type whose
	result would fall outside the range [min(),max()], the value
	returned differs from the true value by an integer multiple of
	max() - min() + 1. On most machines, this is false for floating
	types, true for unsigned integers, and true for signed integers.
	See PR22200 about signed integers.  */
    static const bool is_modulo = false;

    /** True if trapping is implemented for this type.  */
    static const bool traps = false;

    /** True if tininess is detected before rounding.  (see IEC 559)  */
    static const bool tinyness_before = false;

    /** See std::float_round_style for more information.  This is only
	meaningful for floating types; integer types will all be
	round_toward_zero.  */
    static const float_round_style round_style = 
						    round_toward_zero;
  };

  /**
   *  @brief Properties of fundamental types.
   *
   *  This class allows a program to obtain information about the
   *  representation of a fundamental type on a given platform.  For
   *  non-fundamental types, the functions will return 0 and the data
   *  members will all be @c false.
   *
   *  _GLIBCXX_RESOLVE_LIB_DEFECTS:  DRs 201 and 184 (hi Gaby!) are
   *  noted, but not incorporated in this documented (yet).
  */
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {
      /** The minimum finite value, or for floating types with
	  denormalization, the minimum positive normalized value.  */
      static const _Tp
      min() { return _Tp(); }

      /** The maximum finite value.  */
      static const _Tp
      max() { return _Tp(); }

#if __cplusplus >= 201103L
      /** A finite value x such that there is no other finite value y
       *  where y < x.  */
      static constexpr _Tp
      lowest() noexcept { return _Tp(); }
#endif

      /** The @e machine @e epsilon:  the difference between 1 and the least
	  value greater than 1 that is representable.  */
      static const _Tp
      epsilon() { return _Tp(); }

      /** The maximum rounding error measurement (see LIA-1).  */
      static const _Tp
      round_error() { return _Tp(); }

      /** The representation of positive infinity, if @c has_infinity.  */
      static const _Tp
      infinity() { return _Tp(); }

      /** The representation of a quiet Not a Number,
	  if @c has_quiet_NaN. */
      static const _Tp
      quiet_NaN() { return _Tp(); }

      /** The representation of a signaling Not a Number, if
	  @c has_signaling_NaN. */
      static const _Tp
      signaling_NaN() { return _Tp(); }

      /** The minimum positive denormalized value.  For types where
	  @c has_denorm is false, this is the minimum positive normalized
	  value.  */
      static const _Tp
      denorm_min() { return _Tp(); }
    };

#if __cplusplus >= 201103L
  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
#endif

  // Now there follow 16 explicit specializations.  Yes, 16.  Make sure
  // you get the count right. (18 in c++0x mode)

  /// numeric_limits<bool> specialization.
  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static const bool 
      min() { return false; }

      static const bool 
      max() { return true; }

#if __cplusplus >= 201103L
      static constexpr bool
      lowest() noexcept { return min(); }
#endif
      static const int digits = 1;
      static const int digits10 = 0;
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static const bool 
      epsilon() { return false; }

      static const bool 
      round_error() { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm 
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static const bool 
      infinity() { return false; }

      static const bool 
      quiet_NaN() { return false; }

      static const bool 
      signaling_NaN() { return false; }

      static const bool 
      denorm_min() { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      // It is not clear what it means for a boolean type to trap.
      // This is a DR on the LWG issue list.  Here, I use integer
      // promotion semantics.
      static const bool traps = __glibcxx_integral_traps;
      static const bool tinyness_before = false;
      static const float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<char> specialization.
  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static const char 
      min() { return __glibcxx_min(char); }

      static const char 
      max() { return __glibcxx_max(char); }

#if __cplusplus >= 201103L
      static constexpr char 
      lowest() noexcept { return min(); }
#endif

      static const int digits = __glibcxx_digits (char);
      static const int digits10 = __glibcxx_digits10 (char);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static const bool is_signed = __glibcxx_signed (char);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static const char 
      epsilon() { return 0; }

      static const char 
      round_error() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm 
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static const 
      char infinity() { return char(); }

      static const char 
      quiet_NaN() { return char(); }

      static const char 
      signaling_NaN() { return char(); }

      static const char 
      denorm_min() { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = !is_signed;

      static const bool traps = __glibcxx_integral_traps;
      static const bool tinyness_before = false;
      static const float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<signed char> specialization.
  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static const signed char 
      min() { return -SCHAR_MAX - 1; }

      static const signed char 
      max() { return SCHAR_MAX; }

#if __cplusplus >= 201103L
      static constexpr signed char 
      lowest() noexcept { return min(); }
#endif

      static const int digits = __glibcxx_digits (signed char);
      static const int digits10 
       = __glibcxx_digits10 (signed char);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static const signed char 
      epsilon() { return 0; }

      static const signed char 
      round_error() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm 
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static const signed char 
      infinity() { return static_cast<signed char>(0); }

      static const signed char 
      quiet_NaN() { return static_cast<signed char>(0); }

      static const signed char 
      signaling_NaN() 
      { return static_cast<signed char>(0); }

      static const signed char 
      denorm_min() 
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = __glibcxx_integral_traps;
      static const bool tinyness_before = false;
      static const float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<unsigned char> specialization.
  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static const unsigned char 
      min() { return 0; }

      static const unsigned char 
      max() { return SCHAR_MAX * 2U + 1; }

#if __cplusplus >= 201103L
      static constexpr unsigned char 
      lowest() noexcept { return min(); }
#endif

      static const int digits 
       = __glibcxx_digits (unsigned char);
      static const int digits10 
       = __glibcxx_digits10 (unsigned char);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static const unsigned char 
      epsilon() { return 0; }

      static const unsigned char 
      round_error() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm 
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static const unsigned char 
      infinity() 
      { return static_cast<unsigned char>(0); }

      static const unsigned char 
      quiet_NaN() 
      { return static_cast<unsigned char>(0); }

      static const unsigned char 
      signaling_NaN() 
      { return static_cast<unsigned char>(0); }

      static const unsigned char 
      denorm_min() 
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = __glibcxx_integral_traps;
      static const bool tinyness_before = false;
      static const float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<wchar_t> specialization.
  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static const wchar_t 
      min() { return __glibcxx_min (wchar_t); }

      static const wchar_t 
      max() { return __glibcxx_max (wchar_t); }

#if __cplusplus >= 201103L
      static constexpr wchar_t
      lowest() noexcept { return min(); }
#endif

      static const int digits = __glibcxx_digits (wchar_t);
      static const int digits10 
       = __glibcxx_digits10 (wchar_t);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static const bool is_signed = __glibcxx_signed (wchar_t);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static const wchar_t 
      epsilon() { return 0; }

      static const wchar_t 
      round_error() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm 
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static const wchar_t 
      infinity() { return wchar_t(); }

      static const wchar_t 
      quiet_NaN() { return wchar_t(); }

      static const wchar_t 
      signaling_NaN() { return wchar_t(); }

      static const wchar_t 
      denorm_min() { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = !is_signed;

      static const bool traps = __glibcxx_integral_traps;
      static const bool tinyness_before = false;
      static const float_round_style round_style 
       = round_toward_zero;
    };

#if __cplusplus >= 201103L
  /// numeric_limits<char16_t> specialization.
  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t 
      min() noexcept { return __glibcxx_min (char16_t); }

      static constexpr char16_t 
      max() noexcept { return __glibcxx_max (char16_t); }

      static constexpr char16_t 
      lowest() noexcept { return min(); }

      static constexpr int digits = __glibcxx_digits (char16_t);
      static constexpr int digits10 = __glibcxx_digits10 (char16_t);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = __glibcxx_signed (char16_t);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t 
      epsilon() noexcept { return 0; }

      static constexpr char16_t 
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t 
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t 
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t 
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t 
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = __glibcxx_integral_traps;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };

  /// numeric_limits<char32_t> specialization.
  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t 
      min() noexcept { return __glibcxx_min (char32_t); }

      static constexpr char32_t 
      max() noexcept { return __glibcxx_max (char32_t); }

      static constexpr char32_t 
      lowest() noexcept { return min(); }

      static constexpr int digits = __glibcxx_digits (char32_t);
      static constexpr int digits10 = __glibcxx_digits10 (char32_t);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = __glibcxx_signed (char32_t);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t 
      epsilon() noexcept { return 0; }

      static constexpr char32_t 
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t 
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t 
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t 
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t 
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = __glibcxx_integral_traps;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };
#endif

  /// numeric_limits<short> specialization.
  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static const short 
      min() { return -SHRT_MAX - 1; }

      static const short 
      max() { return SHRT_MAX; }

#if __cplusplus >= 201103L
      static constexpr short 
      lowest() noexcept { return min(); }
#endif

      static const int digits = __glibcxx_digits (short);
      static const int digits10 = __glibcxx_digits10 (short);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static const short 
      epsilon() { return 0; }

      static const short 
      round_error() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm 
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static const short 
      infinity() { return short(); }

      static const short 
      quiet_NaN() { return short(); }

      static const short 
      signaling_NaN() { return short(); }

      static const short 
      denorm_min() { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = __glibcxx_integral_traps;
      static const bool tinyness_before = false;
      static const float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<unsigned short> specialization.
  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static const unsigned short 
      min() { return 0; }

      static const unsigned short 
      max() { return SHRT_MAX * 2U + 1; }

#if __cplusplus >= 201103L
      static constexpr unsigned short 
      lowest() noexcept { return min(); }
#endif

      static const int digits 
       = __glibcxx_digits (unsigned short);
      static const int digits10 
       = __glibcxx_digits10 (unsigned short);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static const unsigned short 
      epsilon() { return 0; }

      static const unsigned short 
      round_error() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm 
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static const unsigned short 
      infinity() 
      { return static_cast<unsigned short>(0); }

      static const unsigned short 
      quiet_NaN() 
      { return static_cast<unsigned short>(0); }

      static const unsigned short 
      signaling_NaN() 
      { return static_cast<unsigned short>(0); }

      static const unsigned short 
      denorm_min() 
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = __glibcxx_integral_traps;
      static const bool tinyness_before = false;
      static const float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<int> specialization.
  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static const int 
      min() { return -__INT_MAX__ - 1; }

      static const int 
      max() { return __INT_MAX__; }

#if __cplusplus >= 201103L
      static constexpr int 
      lowest() noexcept { return min(); }
#endif

      static const int digits = __glibcxx_digits (int);
      static const int digits10 = __glibcxx_digits10 (int);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static const int 
      epsilon() { return 0; }

      static const int 
      round_error() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm 
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static const int 
      infinity() { return static_cast<int>(0); }

      static const int 
      quiet_NaN() { return static_cast<int>(0); }

      static const int 
      signaling_NaN() { return static_cast<int>(0); }

      static const int 
      denorm_min() { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = __glibcxx_integral_traps;
      static const bool tinyness_before = false;
      static const float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<unsigned int> specialization.
  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static const unsigned int 
      min() { return 0; }

      static const unsigned int 
      max() { return __INT_MAX__ * 2U + 1; }

#if __cplusplus >= 201103L
      static constexpr unsigned int 
      lowest() noexcept { return min(); }
#endif

      static const int digits 
       = __glibcxx_digits (unsigned int);
      static const int digits10 
       = __glibcxx_digits10 (unsigned int);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static const unsigned int 
      epsilon() { return 0; }

      static const unsigned int 
      round_error() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm 
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static const unsigned int 
      infinity() { return static_cast<unsigned int>(0); }

      static const unsigned int 
      quiet_NaN() 
      { return static_cast<unsigned int>(0); }

      static const unsigned int 
      signaling_NaN() 
      { return static_cast<unsigned int>(0); }

      static const unsigned int 
      denorm_min() 
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = __glibcxx_integral_traps;
      static const bool tinyness_before = false;
      static const float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<long> specialization.
  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static const long
      min() { return -__LONG_MAX__ - 1; }

      static const long 
      max() { return __LONG_MAX__; }

#if __cplusplus >= 201103L
      static constexpr long 
      lowest() noexcept { return min(); }
#endif

      static const int digits = __glibcxx_digits (long);
      static const int digits10 = __glibcxx_digits10 (long);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static const long 
      epsilon() { return 0; }

      static const long 
      round_error() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm 
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static const long 
      infinity() { return static_cast<long>(0); }

      static const long 
      quiet_NaN() { return static_cast<long>(0); }

      static const long 
      signaling_NaN() { return static_cast<long>(0); }

      static const long 
      denorm_min() { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = __glibcxx_integral_traps;
      static const bool tinyness_before = false;
      static const float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<unsigned long> specialization.
  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static const unsigned long 
      min() { return 0; }

      static const unsigned long 
      max() { return __LONG_MAX__ * 2UL + 1; }

#if __cplusplus >= 201103L
      static constexpr unsigned long 
      lowest() noexcept { return min(); }
#endif

      static const int digits 
       = __glibcxx_digits (unsigned long);
      static const int digits10 
       = __glibcxx_digits10 (unsigned long);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static const unsigned long 
      epsilon() { return 0; }

      static const unsigned long 
      round_error() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm 
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static const unsigned long 
      infinity() 
      { return static_cast<unsigned long>(0); }

      static const unsigned long 
      quiet_NaN() 
      { return static_cast<unsigned long>(0); }

      static const unsigned long 
      signaling_NaN() 
      { return static_cast<unsigned long>(0); }

      static const unsigned long 
      denorm_min() 
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = __glibcxx_integral_traps;
      static const bool tinyness_before = false;
      static const float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<long long> specialization.
  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static const long long 
      min() { return -__LONG_LONG_MAX__ - 1; }

      static const long long 
      max() { return __LONG_LONG_MAX__; }

#if __cplusplus >= 201103L
      static constexpr long long 
      lowest() noexcept { return min(); }
#endif

      static const int digits 
       = __glibcxx_digits (long long);
      static const int digits10 
       = __glibcxx_digits10 (long long);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static const long long 
      epsilon() { return 0; }

      static const long long 
      round_error() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm 
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static const long long 
      infinity() { return static_cast<long long>(0); }

      static const long long 
      quiet_NaN() { return static_cast<long long>(0); }

      static const long long 
      signaling_NaN() 
      { return static_cast<long long>(0); }

      static const long long 
      denorm_min() { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = __glibcxx_integral_traps;
      static const bool tinyness_before = false;
      static const float_round_style round_style 
       = round_toward_zero;
    };

  /// numeric_limits<unsigned long long> specialization.
  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static const unsigned long long 
      min() { return 0; }

      static const unsigned long long 
      max() { return __LONG_LONG_MAX__ * 2ULL + 1; }

#if __cplusplus >= 201103L
      static constexpr unsigned long long 
      lowest() noexcept { return min(); }
#endif

      static const int digits 
       = __glibcxx_digits (unsigned long long);
      static const int digits10 
       = __glibcxx_digits10 (unsigned long long);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static const unsigned long long 
      epsilon() { return 0; }

      static const unsigned long long 
      round_error() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm 
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static const unsigned long long 
      infinity() 
      { return static_cast<unsigned long long>(0); }

      static const unsigned long long 
      quiet_NaN() 
      { return static_cast<unsigned long long>(0); }

      static const unsigned long long 
      signaling_NaN() 
      { return static_cast<unsigned long long>(0); }

      static const unsigned long long 
      denorm_min() 
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = __glibcxx_integral_traps;
      static const bool tinyness_before = false;
      static const float_round_style round_style 
       = round_toward_zero;
    };

#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)
  /// numeric_limits<__int128> specialization.
  template<>
    struct numeric_limits<__int128>
    {
      static const bool is_specialized = true;

      static const __int128
      min() { return __glibcxx_min (__int128); }

      static const __int128
      max() { return __glibcxx_max (__int128); }

#if __cplusplus >= 201103L
      static constexpr __int128
      lowest() noexcept { return min(); }
#endif

      static const int digits
       = __glibcxx_digits (__int128);
      static const int digits10
       = __glibcxx_digits10 (__int128);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static const __int128
      epsilon() { return 0; }

      static const __int128
      round_error() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static const __int128
      infinity() 
      { return static_cast<__int128>(0); }

      static const __int128
      quiet_NaN() 
      { return static_cast<__int128>(0); }
      
      static const __int128
      signaling_NaN() 
      { return static_cast<__int128>(0); }
      
      static const __int128
      denorm_min() 
      { return static_cast<__int128>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps
       = __glibcxx_integral_traps;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };

  /// numeric_limits<unsigned __int128> specialization.
  template<>
    struct numeric_limits<unsigned __int128>
    {
      static const bool is_specialized = true;

      static const unsigned __int128
      min() { return 0; }

      static const unsigned __int128
      max() { return __glibcxx_max (unsigned __int128); }

#if __cplusplus >= 201103L
      static constexpr unsigned __int128
      lowest() noexcept { return min(); }
#endif

      static const int digits
       = __glibcxx_digits (unsigned __int128);
      static const int digits10
       = __glibcxx_digits10 (unsigned __int128);
#if __cplusplus >= 201103L
      static constexpr int max_digits10 = 0;
#endif
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static const unsigned __int128
      epsilon() { return 0; }

      static const unsigned __int128
      round_error() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static const unsigned __int128
      infinity() 
      { return static_cast<unsigned __int128>(0); }

      static const unsigned __int128
      quiet_NaN() 
      { return static_cast<unsigned __int128>(0); }

      static const unsigned __int128
      signaling_NaN() 
      { return static_cast<unsigned __int128>(0); }

      static const unsigned __int128
      denorm_min() 
      { return static_cast<unsigned __int128>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = __glibcxx_integral_traps;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
#endif

  /// numeric_limits<float> specialization.
  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static const float 
      min() { return FLT_MIN; }

      static const float 
      max() { return FLT_MAX; }

#if __cplusplus >= 201103L
      static constexpr float 
      lowest() noexcept { return -FLT_MAX; }
#endif

      static const int digits = FLT_MANT_DIG;
      static const int digits10 = FLT_DIG;
#if __cplusplus >= 201103L
      static constexpr int max_digits10
	 = __glibcxx_max_digits10 (FLT_MANT_DIG);
#endif
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = FLT_RADIX;

      static const float 
      epsilon() { return FLT_EPSILON; }

      static const float 
      round_error() { return 0.5F; }

      static const int min_exponent = FLT_MIN_EXP;
      static const int min_exponent10 = FLT_MIN_10_EXP;
      static const int max_exponent = FLT_MAX_EXP;
      static const int max_exponent10 = FLT_MAX_10_EXP;

      static const bool has_infinity = true;
      static const bool has_quiet_NaN = true;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
	= denorm_present;
      static const bool has_denorm_loss 
       = __glibcxx_float_has_denorm_loss;

      static const float 
      infinity() { return HUGE_VALF; }

      static const float 
      quiet_NaN() { return nanf(""); }

      static const float 
      signaling_NaN() { return nanf(""); }

      static const float 
      denorm_min() { return FLT_MIN; }

      static const bool is_iec559
	= has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = __glibcxx_float_traps;
      static const bool tinyness_before 
       = __glibcxx_float_tinyness_before;
      static const float_round_style round_style 
       = round_to_nearest;
    };

#undef __glibcxx_float_has_denorm_loss
#undef __glibcxx_float_traps
#undef __glibcxx_float_tinyness_before

  /// numeric_limits<double> specialization.
  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static const double 
      min() { return DBL_MIN; }

      static const double 
      max() { return DBL_MAX; }

#if __cplusplus >= 201103L
      static constexpr double 
      lowest() noexcept { return -DBL_MAX; }
#endif

      static const int digits = DBL_MANT_DIG;
      static const int digits10 = DBL_DIG;
#if __cplusplus >= 201103L
      static constexpr int max_digits10
	 = __glibcxx_max_digits10 (DBL_MANT_DIG);
#endif
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = FLT_RADIX;

      static const double 
      epsilon() { return DBL_EPSILON; }

      static const double 
      round_error() { return 0.5; }

      static const int min_exponent = DBL_MIN_EXP;
      static const int min_exponent10 = DBL_MIN_10_EXP;
      static const int max_exponent = DBL_MAX_EXP;
      static const int max_exponent10 = DBL_MAX_10_EXP;

      static const bool has_infinity = true;
      static const bool has_quiet_NaN = true;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
	= denorm_present;
      static const bool has_denorm_loss 
        = __glibcxx_double_has_denorm_loss;

      static const double 
      infinity() { return HUGE_VAL; }

      static const double 
      quiet_NaN() { return nan(""); }

      static const double 
      signaling_NaN() { return nan(""); }

      static const double 
      denorm_min() { return DBL_MIN; }

      static const bool is_iec559
	= has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = __glibcxx_double_traps;
      static const bool tinyness_before 
       = __glibcxx_double_tinyness_before;
      static const float_round_style round_style 
       = round_to_nearest;
    };

#undef __glibcxx_double_has_denorm_loss
#undef __glibcxx_double_traps
#undef __glibcxx_double_tinyness_before

  /// numeric_limits<long double> specialization.
  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static const long double 
      min() { return LDBL_MIN; }

      static const long double 
      max() { return LDBL_MAX; }

#if __cplusplus >= 201103L
      static constexpr long double 
      lowest() noexcept { return -LDBL_MAX; }
#endif

      static const int digits = LDBL_MANT_DIG;
      static const int digits10 = LDBL_DIG;
#if __cplusplus >= 201103L
      static const int max_digits10
	 = __glibcxx_max_digits10 (LDBL_MANT_DIG);
#endif
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = FLT_RADIX;

      static const long double 
      epsilon() { return LDBL_EPSILON; }

      static const long double 
      round_error() { return 0.5L; }

      static const int min_exponent = LDBL_MIN_EXP;
      static const int min_exponent10 = LDBL_MIN_10_EXP;
      static const int max_exponent = LDBL_MAX_EXP;
      static const int max_exponent10 = LDBL_MAX_10_EXP;

      static const bool has_infinity = true;
      static const bool has_quiet_NaN = true;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
	= denorm_present;
      static const bool has_denorm_loss
	= __glibcxx_long_double_has_denorm_loss;

      static const long double 
      infinity() { return HUGE_VAL; }

      static const long double 
      quiet_NaN() { return nanl(""); }

      static const long double 
      signaling_NaN() { return nanl(""); }

      static const long double 
      denorm_min() { return LDBL_MIN; }

      static const bool is_iec559
	= has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = __glibcxx_long_double_traps;
      static const bool tinyness_before = 
					 __glibcxx_long_double_tinyness_before;
      static const float_round_style round_style = 
						      round_to_nearest;
    };

#undef __glibcxx_long_double_has_denorm_loss
#undef __glibcxx_long_double_traps
#undef __glibcxx_long_double_tinyness_before

} // namespace

#undef __glibcxx_signed
#undef __glibcxx_min
#undef __glibcxx_max
#undef __glibcxx_digits
#undef __glibcxx_digits10
#undef __glibcxx_max_digits10

#endif // _GLIBCXX_NUMERIC_LIMITS
